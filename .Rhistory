library()
library(ggplot2)
a<-available.packages()
head(rownames(a),3)
install.packages(""slidify)
install.packages(""slidify"")
install.packages(""slidify")
install.packages("slidify")
library(ggplot2)
install.packages("ggplot2")
library(ggplot2)
str(apply)
x <- matrix(rnorm(200), 20, 10)
x
b <- apply(x, 2, mean)
b
c <- apply(x, 1, sum)
с
с
с
с
c
d <- apply(x, 1, quanile, probs = c(0.25, 0,75))
d <- apply(x, 1, quantile, probs = c(0.25, 0,75))
d <- apply(x, 1, quantile, probs = c(0.25, 0.75))
в
d <- apply(x, 1, quantile, probs = c(0.25, 0.75))
в
d
e <- apply(x, 2, quantile, probs = c(0.25, 0.75))
e
a <- array(rnorm(2 * 2 * 10), c(2, 2, 10))
a
apply(a, c[1,2], mean)
apply(a, c(1,2), mean)
rowMeans(a, dims = 2)
mapply(rep, 1:4, 4:1)
noise(5,1,2)
x <- matrix(rnorm(200), 20, 10)
x <- matrix(rnorm(4), 2, 2)
solve(x)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get
m<-solve(matrix, ...)
x$setmatrix(m)
m
## Return a matrix that is the inverse of 'x'
}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get()
m<-solve(matrix, ...)
x$setmatrix(m)
m
## Return a matrix that is the inverse of 'x'
}
a
cacheSolve(a)
a <- matrix (1:4, 2, 2)
a
cacheSolve(a)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get()
m<-solve(matrix, ...)
x$setmatrix(m)
m
## Return a matrix that is the inverse of 'x'
}
cacheSolve(a)
a1 <- makeCacheMatrix(a)
cacheSolve(a1)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
matrix_inv<-NULL
set<-function(y){
x<<-y
matrix_inv<<-NULL
}
get<-function() x
setmatrix<-function(solve) matrix_inv<<- solve
getmatrix<-function() matrix_inv
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
matrix_inv<-x$getmatrix()
if(!is.null(matrix_inv)){
message("getting cached data")
return(matrix_inv)
}
matrix<-x$get()
matrix_inv<-solve(matrix, ...)
x$setmatrix(matrix_inv)
matrix_inv
## Return a matrix that is the inverse of 'x'
}
a1 <- makeCacheMatrix(a)
cacheSolve(a1)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
matrix_inv<-NULL
set<-function(y){
x<<-y
matrix_inv<<-NULL
}
get<-function() x
setmatrix_inv<-function(solve) matrix_inv<<- solve
getmatrix_inv<-function() matrix_inv
list(set=set, get=get,
setmatrix_inv=setmatrix_inv,
getmatrix_inv=getmatrix_Inv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
matrix_inv<-x$getmatrix_inv()
if(!is.null(matrix_inv)){
message("getting cached data")
return(matrix_inv)
}
matrix<-x$get()
matrix_inv<-solve(matrix, ...)
x$setmatrix_inv(matrix_inv)
matrix_inv
## Return a matrix that is the inverse of 'x'
}
a1 <- makeCacheMatrix(a)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
matrix_inv<-NULL
set<-function(y){
x<<-y
matrix_inv<<-NULL
}
get<-function() x
setmatrix_inv<-function(solve) matrix_inv<<- solve
getmatrix_inv<-function() matrix_inv
list(set=set, get=get,
setmatrix_inv=setmatrix_inv,
getmatrix_inv=getmatrix_inv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
matrix_inv<-x$getmatrix_inv()
if(!is.null(matrix_inv)){
message("getting cached data")
return(matrix_inv)
}
matrix<-x$get()
matrix_inv<-solve(matrix, ...)
x$setmatrix_inv(matrix_inv)
matrix_inv
## Return a matrix that is the inverse of 'x'
}
a1 <- makeCacheMatrix(a)
cacheSolve(a1)
## Put comments here that give an overall description of what your
## functions do
## create a structure of the matrix function
makeCacheMatrix <- function(x = matrix()) {
## create a null value of the inverse matrix
matrix_inv<-NULL
set<-function(y){
x<<-y
## if the matrix was changed, change the value of inverse matrix
matrix_inv<<-NULL
}
##recieve the value of the inverse matrix
get<-function() x
setmatrix_inv<-function(solve) matrix_inv<<- solve
## get the inverse matrix
getmatrix_inv<-function() matrix_inv
list(set=set, get=get,
setmatrix_inv=setmatrix_inv,
getmatrix_inv=getmatrix_inv)
}
## recieve the cash of the matrix
cacheSolve <- function(x, ...) {
matrix_inv<-x$getmatrix_inv()
if(!is.null(matrix_inv)){
message("getting cached data")
return(matrix_inv)
}
#in case the inverse matrix not calculated earlier, first it is calculated and then retrieved
matrix<-x$get()
matrix_inv<-solve(matrix, ...)
x$setmatrix_inv(matrix_inv)
matrix_inv
## Return a matrix that is the inverse of 'x'
}
a1 <- makeCacheMatrix(a)
cacheSolve(a1)
HaversineDistance=function(lat1,lon1,lat2,lon2)
{
#returns the distance in km
REarth<-6371
lat<-abs(lat1-lat2)*pi/180
lon<-abs(lon1-lon2)*pi/180
lat1<-lat1*pi/180
lat2<-lat2*pi/180
a<-sin(lat/2)*sin(lat/2)+cos(lat1)*cos(lat2)*sin(lon/2)*sin(lon/2)
d<-2*atan2(sqrt(a),sqrt(1-a))
d<-REarth*d
return(d)
}
RMSE<-function(pre,real)
{
return(sqrt(mean((pre-real)*(pre-real))))
}
meanHaversineDistance<-function(lat1,lon1,lat2,lon2)
{
return(mean(HaversineDistance(lat1,lon1,lat2,lon2)))
}
#USAGE
#
#FUNCTION PARAMETERS: @submission,@answers
#@submission: path+filename containing the answers to submit in CSV format
#@answers: path+filename containing the answers to evaluate the submission in CSV format
travelTime.PredictionEvaluation<-function(submission,answers)
{
dt<-read.csv(submission)
tt_sub<-dt[,2]
dt<-read.csv(answers)
tt_real<-dt[,2]
return (RMSE(tt_sub,tt_real))
}
#USAGE
#
#FUNCTION PARAMETERS: @submission,@answers
#@submission: path+filename containing the answers to submit in CSV format
#@answers: path+filename containing the answers to evaluate the submission in CSV format
destinationMining.Evaluation<-function(submission,answers)
{
dt<-read.csv(submission)
lat_sub<-dt[,2]
lon_sub<-dt[,3]
dt<-read.csv(answers)
lat_real<-dt[,2]
lon_real<-dt[,3]
return (meanHaversineDistance(lat_sub,lon_sub,lat_real,lon_real))
}
con = url("http://www.championat.com/football/_russiapl/1014/result.html")
htmlCode = readLines(con)
close
close(con)
htmlCode
library(XML)
install.packages("XML")
library(XML)
url <- "http://www.championat.com/football/_russiapl/1014/result.html"
html <- htmlTreeParse(url, useInternalNodes=T)
xpathSApply(html, "//title", xmlValue)
xpathSApply(html, "//td[@id='_res']", xmlValue)
a <- xpathSApply(html, "//td[@id='_res']", xmlValue)
a
a <- xpathSApply(html, "//a", xmlValue)
a <- xpathSApply(html, "//td[@class='_res']", xmlValue)
library(httr)
install.packages("httr")
library(httr)
oauth_endpoints("github")
myapp <- oauth_app("github", "ClientID", "ClientSecret")
github_token <- oauth2.0_token(oauth_endpoints("github"), myapp)
clear
clear()
library(datasets)
data(airquality)
airquality = transform(airquality, Month = factor(Month))
qplot(Wind, Ozone, data = airquality, facets = . ~ Month)
library(ggplot2)
airquality = transform(airquality, Month = factor(Month))
qplot(Wind, Ozone, data = airquality, facets = . ~ Month)
qplot(Wind, Ozone, data = airquality, geom = "smooth")
measure <- function(lon1,lat1,lon2,lat2) {
R <- 6378.137                                # radius of earth in Km
dLat <- (lat2-lat1)*pi/180
dLon <- (lon2-lon1)*pi/180
a <- sin((dLat/2))^2 + cos(lat1*pi/180)*cos(lat2*pi/180)*(sin(dLon/2))^2
c <- 2 * atan2(sqrt(a), sqrt(1-a))
d <- R * c
return (d * 1000)                            # distance in meters
}
measure(-122.425891675136, 37.7745985956747, -122.419087676747, 37.8078015516515)
basedir <- "D:/Users/DMudrov/Desktop/datas/bearing_IMS (vibration)/1st_test/1st_test"
data <- read.table(paste0(basedir, "2003.10.22.12.06.24"), header=FALSE, sep="\t")
head(data)
basedir <- "D:/Users/DMudrov/Desktop/datas/bearing_IMS (vibration)/1st_test/1st_test/"
data <- read.table(paste0(basedir, "2003.10.22.12.06.24"), header=FALSE, sep="\t")
head(data)
colnames(data) <- c("b1.x", "b1.y", "b2.x", "b2.y", "b3.x", "b3.y", "b4.x", "b4.y")
b1.x.fft <- fft(data$b1.x)
amplitude <- Mod(b1.x.fft[1:(length(b1.x.fft)/2)])
frequency <- seq(0, 10000, length.out=length(b1.x.fft)/2)
plot(amplitude ~ frequency, t="l")
sorted <- sort.int(amplitude, decreasing=TRUE, index.return=TRUE)
top15 <- sorted$ix[1:15]
top15f <- frequency[top15]
top15f
fft.profile <- function (dataset, n)
{
fft.data <- fft(dataset)
amplitude <- Mod(fft.data[1:(length(fft.data)/2)])
frequencies <- seq(0, 10000, length.out=length(fft.data)/2)
sorted <- sort.int(amplitude, decreasing=TRUE, index.return=TRUE)
top <- sorted$ix[1:n] # indexes of the largest n components
return (frequencies[top]) # convert indexes to frequencies
}
timestamp <- as.character(strptime(filename, format="%Y.%m.%d.%H.%M.%S"))
n <- 5
b1 <- matrix(nrow=0, ncol=(2*n+1))
b2 <- matrix(nrow=0, ncol=(2*n+1))
b3 <- matrix(nrow=0, ncol=(2*n+1))
b4 <- matrix(nrow=0, ncol=(2*n+1))
for (filename in list.files(basedir))
{
cat("Processing file ", filename, "\n")
timestamp <- as.character(strptime(filename, format="%Y.%m.%d.%H.%M.%S"))
data <- read.table(paste0(basedir, filename), header=FALSE, sep="\t")
colnames(data) <- c("b1.x", "b1.y", "b2.x", "b2.y", "b3.x", "b3.y", "b4.x", "b4.y")
# Bind the new rows to the bearing matrices
b1 <- rbind(b1, c(timestamp, fft.profile(data$b1.x, n), fft.profile(data$b1.y, n)))
b2 <- rbind(b2, c(timestamp, fft.profile(data$b2.x, n), fft.profile(data$b2.y, n)))
b3 <- rbind(b3, c(timestamp, fft.profile(data$b3.x, n), fft.profile(data$b3.y, n)))
b4 <- rbind(b4, c(timestamp, fft.profile(data$b4.x, n), fft.profile(data$b4.y, n)))
}
View(`b1`)
View(data)
c_n <- c("date_time", "X1", "X2", "X3", "X4", "X5", "Y1", "Y2", "Y3", "Y4", "Y5")
write.table(b1, file=paste0(basedir, "../b1.csv"), sep=",", row.names=FALSE, col.names=c_n)
write.table(b2, file=paste0(basedir, "../b2.csv"), sep=",", row.names=FALSE, col.names=c_n)
write.table(b3, file=paste0(basedir, "../b3.csv"), sep=",", row.names=FALSE, col.names=c_n)
write.table(b4, file=paste0(basedir, "../b4.csv"), sep=",", row.names=FALSE, col.names=c_n)
install.packages("knitr")
setwd("D:/Users/DMudrov/Desktop/study/dataScience/myDataScience/5d")
data <- read.csv("activity.csv")
data$date <- as.POSIXct(data$date)
knit2html()
import knitr
library(knitr)
knit2html()
knit2html(PA1_tem.Rmd)
knit2html('PA1_tem.Rmd')
